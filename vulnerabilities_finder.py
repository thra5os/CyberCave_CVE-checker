import csv
import wmi
import winreg

import nvdlib

import multiprocessing as mp
import subprocess
from pprint import pprint

import requests
from packaging import version

from vulnerability_classes import *
from vulnerabilities_metrics import *
from mitrecve import crawler

import pandas as pd
import re

import os
from pathlib import Path

import time


def get_installed_apps2():
    w = wmi.WMI()
    apps = []

    # Get apps from Win32_Product WMI class
    for product in w.query("SELECT * FROM Win32_Product"):
        app = {
            "name": product.Name,
            "version": product.Version,
            "vendor": product.Vendor,
            "install_date": str(product.InstallDate),
        }
        apps.append(app)

    # Get apps from UninstallKey registry keys
    registry_keys = [
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    ]

    for registry_key in registry_keys:
        for i in range(1000):
            try:
                subkey = winreg.EnumKey(registry_key, i)
                key = winreg.OpenKey(registry_key, subkey)
                name = winreg.QueryValueEx(key, "DisplayName")[0]
                version = winreg.QueryValueEx(key, "DisplayVersion")[0]
                publisher = winreg.QueryValueEx(key, "Publisher")[0]
                install_date = winreg.QueryValueEx(key, "InstallDate")[0]

                app = {
                    "name": name,
                    "version": version,
                    "vendor": publisher,
                    "install_date": install_date,
                }
                apps.append(app)
            except EnvironmentError:
                break

    return apps

def get_installed_apps():
    # to get the path of the powershell
    powershell_path = r'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'

    # the command to get the list of application and their versions
    powershell_command = r'Get-Package -ProviderName Programs,msi | Select-Object Name, Version | Export-Csv -Path apps.csv -NoTypeInformation'
    # to actually execute the command
    subprocess.call([powershell_path, "-Command", powershell_command], shell=True)

    # use of pandas to remove all empty lines
    apps = pd.read_csv('apps.csv')
    apps = apps.dropna()

    apps['Version'] = apps['Version'].apply(lambda x: re.findall(r'\b\d+(?:\.\d+)*\b', x))

    list_of_apps = apps.to_dict(orient='records')
    dict_of_apps = [{'name': d['Name'], 'version': d['Version'][0]} for d in list_of_apps]

    print(dict_of_apps)

    return dict_of_apps

    # to delete the csv file :
    # subprocess.call([powershell_path, "-Command", "rm apps.csv", shell=True)

def save_to_csv(apps, file_name="windows_apps.csv"):
    keys = apps[0].keys()

    with open(file_name, "w", newline="", encoding="utf-8") as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(apps)

    print(f"CSV file saved as {file_name}")


def cpe_fetcher_subprocess(app, pipe):
    CPE = None
    if(app['name'] == None):
        pipe.send(CPE)
        return
    words = app['name'].split(" ")
    if len(words) > 3:
        simpler_name = words[0] + ' ' + words[1] + ' ' + words[2]
    else:
        simpler_name = app['name']
    print(simpler_name)
    try:

        r = nvdlib.searchCPE(keywordSearch=simpler_name, limit=15, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        #print(r)



        for i in r:

            cpe = i.cpeName

            if('android' in cpe):
                print('android')
                continue
            try:
                cpe_parts = cpe.split(":")
                cpe = cpe_parts[0] + ":" + cpe_parts[1] + ":" + cpe_parts[2] + ":" + cpe_parts[3] + ":" + cpe_parts[4] + ":" + app['version']
                pipe.send([cpe, app])
                return
            except Exception as e:
                print('Exception\n\n\n')
                print(e)

    except Exception as e:
        print(e)
        CPE = None
    pipe.send(CPE)
    return

def cpe_fetcher_mainprocess(apps):
    processes = []
    cpes = []
    for app in apps:
        #value = mp.Value('array')
        #values.append(value)

        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cpe_fetcher_subprocess, args=(app, child_conn)), parent_conn])
    for process in processes:
        time.sleep(1)
        process[0].start()

    for process in processes:
        #print(process[1].recv())
        cpes.append(process[1].recv())

        process[0].join()


    #After processes
    parsed_cpes = []
    for cpe in cpes:
        if cpe != None:
            if cpe not in parsed_cpes or 'Git' in str(cpe):
                parsed_cpes.append(cpe)


    return parsed_cpes


def cve_fetcher_subprocess(cpe, pipe):
    cves = []

    try:
        r = nvdlib.searchCVE(cpeName=cpe[0], key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
    except Exception as e:
        print(e)
        pipe.send([])
        return
    for i in r:
        cves.append([i, cpe[1]])
    pipe.send(cves)
    return



def cve_fetcher_mainprocess(cpes):
    processes = []
    cves = []
    merged_cves = []
    for cpe in cpes:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cve_fetcher_subprocess, args=(cpe, child_conn)), parent_conn])
    for process in processes:
        time.sleep(1)
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        cves.append(process[1].recv())
        process[0].join()
    #print(cves)


    for i in cves:
        for j in i:
            merged_cves.append(j)
    return merged_cves



def vulnerabilities_fetcher(cves):
    vulnerabilities = []
    index = 0
    total = len(cves)
    for cve in cves:
        index += 1
        print(f'{index} / {total}')
        description = ''
        url = ''
        cve_simple = crawler.get_main_page(cve[0])
        for key in cve_simple.keys():
            if(cve[0] == cve_simple[key]['ID']):
                description = cve_simple[key]['DESC']
                url = cve_simple[key]['URL']
                break
        vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, description, url))
    return vulnerabilities

"""def vulnerabilities_fetcher2(cves): 
    group_cves = regroup_by_name(cves)
    for key in group_cves.keys():
        cve_simple = crawler.get_main_page(key)
        for key2 in cve_simple.keys():
            description = ''
            url = ''
            if(cve[0] == cve_simple[key2]['ID']):
                description = cve_simple[key2]['DESC']
                url = cve_simple[key2]['URL']

                vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, description, url))"""

def vulnerabilities_fetcher3(cves):
    vulnerabilities = []
    for cve in cves:
        vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, '', ''))
    return vulnerabilities

def regroup_by_name(cves):
    dic = {}
    for cve in cves:
        if cve[1]['name'] not in dic.keys():
            dic[cve[1]['name']] = [cve]
        else:
            dic[cve[1]['name']].append(cve)
    return dic

def degroup(dic):
    array = []
    for key in dic.keys():
        for cve in dic[key]:
            array.append(cve)
    return array

def CVE_interpreter(vulnerabilities):

    affected_programs = {}
    total = len(vulnerabilities)
    for vuln in vulnerabilities:
        if vuln.app_name in affected_programs.keys():
            affected_programs[vuln.app_name].add_vulnerability(vuln)
        else:
            affected_programs[vuln.app_name] = VulnerableApplication(vuln.app_name)
            affected_programs[vuln.app_name].add_vulnerability(vuln)

    return affected_programs

def fetch_CVEs():
    """
    Download every CVE from mitre database.
    Write data.json file.
    Can be used to update data.json file
    :return: 1
    """
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    request = requests.get("https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=1")
    total = request.json()['totalResults']
    print(total)

    data = {}
    data['vulnerabilities'] = []
    try:
        with open("./CVEs/data.json", "r") as infile:
            data=json.load(infile)
            print(len(data['vulnerabilities']))
            if(len(data['vulnerabilities']) == total):
                print('JSON already up to date')
                #pprint(data['vulnerabilities'][:100])
                return 1
    except FileNotFoundError:
        data = {}
        data['vulnerabilities'] = []
    while(len(data['vulnerabilities']) < total):
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        url = url+'?startIndex='+str(len(data['vulnerabilities']))
        print(url)

        # A GET request to the API
        response = requests.get(url)

        print(response)
        #print(response.text)
        response_json = response.json()
        print(response_json['startIndex'])
        for vuln in response_json['vulnerabilities']:
            data['vulnerabilities'].append(vuln)
    json_data = json.dumps(data)
    with open("./CVEs/data.json", "w") as outfile:
        outfile.write(json_data)
    return 1

def CVE_folder_setup():
    """
    Set up the "CVE" folder
    :return: None
    """
    data_path = Path('./')
    directories = [f for f in data_path.iterdir() if f.is_dir()]
    print(directories)
    print(Path('CVEs') in directories)
    if Path('CVEs') not in directories:
        os.mkdir('./CVEs', )

if __name__ == "__main__":
    CVE_folder_setup()
    fetch_CVEs()
    apps = get_installed_apps()
    print(apps)
    #save_to_csv(apps)
    #print(apps)
    #cve_simple = crawler.get_main_page('CVE-2017-11843')
    #print(cve_simple)
    cpes = cpe_fetcher_mainprocess(apps)

    for cpe in cpes:
        print(cpe)

    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []

    print('---------------------')
    #print(cves)
    for cve in cves:
        #pprint(cve[0])
        cve_ids.append([cve[0].id, cve[1]])

    for cve_id in cve_ids:
        print(cve_id)

    #vulnerabilities_fetcher(cve_ids)



    vulnerabilities = vulnerabilities_fetcher3(cve_ids)

    for vuln in vulnerabilities:
        print(vuln)

    vulnerabilities = CVE_metric(vulnerabilities)

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        print(interpreted[i])


    exit(1)

    for app in apps:

        r = nvdlib.searchCPE(keywordSearch=app['name'], limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        print(app['name'])
        print(r)

def main():
    CVE_folder_setup()
    fetch_CVEs()
    apps = get_installed_apps()
    print('CPE phase')
    cpes = cpe_fetcher_mainprocess(apps)


    print('CVE phase')
    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []


    for cve in cves:

        cve_ids.append([cve[0].id, cve[1]])
    print('vulnerability phase')
    vulnerabilities = vulnerabilities_fetcher3(cve_ids)
    print('metric phase')
    vulnerabilities = CVE_metric(vulnerabilities)
    print('interpreted phase')
    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        #print(interpreted[i])
    return interpreted