import csv
import wmi
import winreg

import nvdlib

import multiprocessing as mp
from pprint import pprint

import requests
from packaging import version

from vulnerability_classes import *
from vulnerabilities_metrics import *
from mitrecve import crawler
def get_installed_apps():
    w = wmi.WMI()
    apps = []

    # Get apps from Win32_Product WMI class
    for product in w.query("SELECT * FROM Win32_Product"):
        app = {
            "name": product.Name,
            "version": product.Version,
            "vendor": product.Vendor,
            "install_date": str(product.InstallDate),
        }
        apps.append(app)

    # Get apps from UninstallKey registry keys
    registry_keys = [
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    ]

    for registry_key in registry_keys:
        for i in range(1000):
            try:
                subkey = winreg.EnumKey(registry_key, i)
                key = winreg.OpenKey(registry_key, subkey)
                name = winreg.QueryValueEx(key, "DisplayName")[0]
                version = winreg.QueryValueEx(key, "DisplayVersion")[0]
                publisher = winreg.QueryValueEx(key, "Publisher")[0]
                install_date = winreg.QueryValueEx(key, "InstallDate")[0]

                app = {
                    "name": name,
                    "version": version,
                    "vendor": publisher,
                    "install_date": install_date,
                }
                apps.append(app)
            except EnvironmentError:
                break

    return apps

def save_to_csv(apps, file_name="windows_apps.csv"):
    keys = apps[0].keys()

    with open(file_name, "w", newline="", encoding="utf-8") as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(apps)

    print(f"CSV file saved as {file_name}")


def cpe_fetcher_subprocess(app, pipe):
    CPE = None
    if(app['name'] == None):
        pipe.send(CPE)
        return
    words = app['name'].split(" ")
    if len(words) > 3:
        simpler_name = words[0] + ' ' + words[1] + ' ' + words[2]
    else:
        simpler_name = app['name']
    print(simpler_name)
    try:

        r = nvdlib.searchCPE(keywordSearch=simpler_name, limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        for i in r:

            cpe = i.cpeName

            if('android' in cpe):
                print('android')
                continue
            try:
                cpe_parts = cpe.split(":")
                cpe = cpe_parts[0] + ":" + cpe_parts[1] + ":" + cpe_parts[2] + ":" + cpe_parts[3] + ":" + cpe_parts[4] + ":" + app['version']
                pipe.send([cpe, app['name']])
                return
            except Exception as e:
                print(e)

    except Exception as e:
        print(e)
        CPE = None
    pipe.send(CPE)
    return

def cpe_fetcher_mainprocess(apps):
    processes = []
    cpes = []
    for app in apps:
        #value = mp.Value('array')
        #values.append(value)

        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cpe_fetcher_subprocess, args=(app, child_conn)), parent_conn])
    for process in processes:
        process[0].start()

    for process in processes:
        #print(process[1].recv())
        cpes.append(process[1].recv())

        process[0].join()


    #After processes
    parsed_cpes = []
    for cpe in cpes:
        if cpe != None:
            if cpe not in parsed_cpes:
                parsed_cpes.append(cpe)


    return parsed_cpes


def cve_fetcher_subprocess(cpe, pipe):
    cves = []

    try:
        r = nvdlib.searchCVE(cpeName=cpe[0], key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
    except Exception as e:
        print(e)
        pipe.send([])
        return
    for i in r:
        cves.append([i, cpe[1]])
    pipe.send(cves)
    return



def cve_fetcher_mainprocess(cpes):
    processes = []
    cves = []
    merged_cves = []
    for cpe in cpes:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cve_fetcher_subprocess, args=(cpe, child_conn)), parent_conn])
    for process in processes:
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        cves.append(process[1].recv())
        process[0].join()
    #print(cves)


    for i in cves:
        for j in i:
            merged_cves.append(j)
    return merged_cves

def vulnerabilities_fetcher_subprocess(cve, pipe):
    """
    Subprocess for CVE generator.
    program ->
    :param program: list with [0]: program name & [1]: program version
    :param pipe: transfer ID
    :return: array of vulnerability objects linked to the program // USELESS // replaced by pipe.send() method
    """
    vulnerabilities = []
    index = 0

    cve_simple = crawler.get_main_page(str(program[0]))
    # cve_array = [x['ID'] for x in cve_simple.values()]

    # for j in cve_array:
    for j in cve_simple.values():
        index += 1
        url = 'https://cveawg.mitre.org/api/cve/' + j['ID']
        request = requests.get(url)
        if request.status_code == 200:
            print('OK - ' + str(index) + ' - ' + str(program[0]))
            # pprint(request.json())
            try:
                keys = request.json()['containers']['cna']['affected'][0]['versions'][0].keys()
            except KeyError:
                keys = ''
                print("Key Error")
            if ('lessThan' in keys):
                try:
                    if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0][
                                         'lessThan']) > version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json()))
                        print('Added')
                        continue
                    else:
                        print('Not Added')
                        continue
                except Exception as e:
                    print("Exception ! - Less")
                    print(e)
                    # WARNING exception doesn't add new vulnerability (no more checks) Corrected ?

            if ('lessThanOrEqual' in keys):
                try:
                    if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0][
                                         'lessThanOrEqual']) >= version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json()))
                        print('Added - equal')
                        continue
                    else:
                        print('Not Added - equal')
                        continue
                except Exception as e:
                    print("Exception ! - Equal")
                    print(e)
            # else:
            try:
                version_temp = version_parser(
                    request.json()['containers']['cna']['affected'][0]['versions'][0]['version'])
            except Exception as e:
                print("Key Error - else")
                print(e)
                vulnerabilities.append(create_vulnerability(program, j, request.json()))
                continue
            if (version_temp == None):

                vulnerabilities.append(create_vulnerability(program, j, request.json()))
                print('Added - Unknown')

            else:
                try:
                    if version.parse(version_temp) >= version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json(), version_temp))
                        print('Added - parse')
                    else:
                        print('Not Added - parse')
                except Exception as e:
                    vulnerabilities.append(create_vulnerability(program, j, request.json(), version_temp))
                    print("Exception ! - Parse")
                    print(e)
    pipe.send(vulnerabilities)
    return vulnerabilities


def vulnerabilities_fetcher_mainprocess(cves):
    """
    Main process for CVE generator.
    Uses fetch_subprocess() method for each program (Parallel processing)
    :param cves: array of arrays with cve IDs
    :return: array with all the configuration's CVEs
    """
    processes = []
    vulnerabilities = []
    merged_list = []
    for cve in cves:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=vulnerabilities_fetcher_subprocess, args=(cve, child_conn)), parent_conn])
    for process in processes:
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        vulnerabilities.append(process[1].recv())
        process[0].join()
    for i in vulnerabilities:
        for j in i:
            merged_list.append(j)
    return merged_list

def vulnerabilities_fetcher(cves):
    vulnerabilities = []
    for cve in cves:
        description = ''
        url = ''
        cve_simple = crawler.get_main_page(cve[1])
        for key in cve_simple.keys():
            if(cve[0] == cve_simple[key]['ID']):
                description = cve_simple[key]['DESC']
                url = cve_simple[key]['URL']
                break
        vulnerabilities.append(Vulnerability(cve[1], 0.0, 'n/a', cve[0], 0.0, description, url))
    return vulnerabilities


def CVE_interpreter(vulnerabilities):

    affected_programs = {}
    for vuln in vulnerabilities:
        if vuln.app_name in affected_programs.keys():
            affected_programs[vuln.app_name].add_vulnerability(vuln)
        else:
            affected_programs[vuln.app_name] = VulnerableApplication(vuln.app_name)
            affected_programs[vuln.app_name].add_vulnerability(vuln)

    return affected_programs

if __name__ == "__main__":
    apps = get_installed_apps()
    save_to_csv(apps)
    print(apps)
    cpes = cpe_fetcher_mainprocess(apps)

    for cpe in cpes:
        print(cpe)

    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []

    print('---------------------')
    #print(cves)
    for cve in cves:
        pprint(cve[0])
        cve_ids.append([cve[0].id, cve[1]])

    for cve_id in cve_ids:
        print(cve_id)

    vulnerabilities_fetcher(cve_ids)



    vulnerabilities = vulnerabilities_fetcher(cve_ids)

    for vuln in vulnerabilities:
        print(vuln)

    vulnerabilities = CVE_metric(vulnerabilities)

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        print(interpreted[i])


    exit(1)

    for app in apps:

        r = nvdlib.searchCPE(keywordSearch=app['name'], limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        print(app['name'])
        print(r)