import csv
import wmi
import winreg

import nvdlib

import multiprocessing as mp
from pprint import pprint

import requests
from packaging import version

from vulnerability_classes import *
from vulnerabilities_metrics import *
from mitrecve import crawler

import os
from pathlib import Path
def get_installed_apps():
    w = wmi.WMI()
    apps = []

    # Get apps from Win32_Product WMI class
    for product in w.query("SELECT * FROM Win32_Product"):
        app = {
            "name": product.Name,
            "version": product.Version,
            "vendor": product.Vendor,
            "install_date": str(product.InstallDate),
        }
        apps.append(app)

    # Get apps from UninstallKey registry keys
    registry_keys = [
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    ]

    for registry_key in registry_keys:
        for i in range(1000):
            try:
                subkey = winreg.EnumKey(registry_key, i)
                key = winreg.OpenKey(registry_key, subkey)
                name = winreg.QueryValueEx(key, "DisplayName")[0]
                version = winreg.QueryValueEx(key, "DisplayVersion")[0]
                publisher = winreg.QueryValueEx(key, "Publisher")[0]
                install_date = winreg.QueryValueEx(key, "InstallDate")[0]

                app = {
                    "name": name,
                    "version": version,
                    "vendor": publisher,
                    "install_date": install_date,
                }
                apps.append(app)
            except EnvironmentError:
                break

    return apps

def save_to_csv(apps, file_name="windows_apps.csv"):
    keys = apps[0].keys()

    with open(file_name, "w", newline="", encoding="utf-8") as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(apps)

    print(f"CSV file saved as {file_name}")


def cpe_fetcher_subprocess(app, pipe):
    CPE = None
    if(app['name'] == None):
        pipe.send(CPE)
        return
    words = app['name'].split(" ")
    if len(words) > 3:
        simpler_name = words[0] + ' ' + words[1] + ' ' + words[2]
    else:
        simpler_name = app['name']
    print(simpler_name)
    try:

        r = nvdlib.searchCPE(keywordSearch=simpler_name, limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        for i in r:

            cpe = i.cpeName

            if('android' in cpe):
                print('android')
                continue
            try:
                cpe_parts = cpe.split(":")
                cpe = cpe_parts[0] + ":" + cpe_parts[1] + ":" + cpe_parts[2] + ":" + cpe_parts[3] + ":" + cpe_parts[4] + ":" + app['version']
                pipe.send([cpe, app['name']])
                return
            except Exception as e:
                print(e)

    except Exception as e:
        print(e)
        CPE = None
    pipe.send(CPE)
    return

def cpe_fetcher_mainprocess(apps):
    processes = []
    cpes = []
    for app in apps:
        #value = mp.Value('array')
        #values.append(value)

        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cpe_fetcher_subprocess, args=(app, child_conn)), parent_conn])
    for process in processes:
        process[0].start()

    for process in processes:
        #print(process[1].recv())
        cpes.append(process[1].recv())

        process[0].join()


    #After processes
    parsed_cpes = []
    for cpe in cpes:
        if cpe != None:
            if cpe not in parsed_cpes:
                parsed_cpes.append(cpe)


    return parsed_cpes


def cve_fetcher_subprocess(cpe, pipe):
    cves = []

    try:
        r = nvdlib.searchCVE(cpeName=cpe[0], key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
    except Exception as e:
        print(e)
        pipe.send([])
        return
    for i in r:
        cves.append([i, cpe[1]])
    pipe.send(cves)
    return



def cve_fetcher_mainprocess(cpes):
    processes = []
    cves = []
    merged_cves = []
    for cpe in cpes:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cve_fetcher_subprocess, args=(cpe, child_conn)), parent_conn])
    for process in processes:
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        cves.append(process[1].recv())
        process[0].join()
    #print(cves)


    for i in cves:
        for j in i:
            merged_cves.append(j)
    return merged_cves

def CVE_folder_setup():
    """
    Set up the "CVE" folder
    :return: None
    """
    data_path = Path('./')
    directories = [f for f in data_path.iterdir() if f.is_dir()]
    print(directories)
    print(Path('CVEs') in directories)
    if Path('CVEs') not in directories:
        os.mkdir('./CVEs', )

def fetch_CVEs():
    """
    Download every CVE from mitre database.
    Write data.json file.
    Can be used to update data.json file
    :return: 1
    """
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    request = requests.get("https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=1")
    total = request.json()['totalResults']
    print(total)

    data = {}
    data['vulnerabilities'] = []
    try:
        with open("./data.json", "r") as infile:
            data=json.load(infile)
            print(len(data['vulnerabilities']))
            if(len(data['vulnerabilities']) == total):
                print('JSON already up to date')
                #pprint(data['vulnerabilities'][:100])
                return 1
    except FileNotFoundError:
        data = {}
        data['vulnerabilities'] = []
    while(len(data['vulnerabilities']) < total):
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        url = url+'?startIndex='+str(len(data['vulnerabilities']))
        print(url)

        # A GET request to the API
        response = requests.get(url)

        print(response)
        #print(response.text)
        response_json = response.json()
        print(response_json['startIndex'])
        for vuln in response_json['vulnerabilities']:
            data['vulnerabilities'].append(vuln)
    json_data = json.dumps(data)
    with open("./data.json", "w") as outfile:
        outfile.write(json_data)
    return 1




def vulnerabilities_fetcher(cves):
    vulnerabilities = []
    for cve in cves:
        description = ''
        url = ''
        cve_simple = crawler.get_main_page(cve[1])
        for key in cve_simple.keys():
            if(cve[0] == cve_simple[key]['ID']):
                description = cve_simple[key]['DESC']
                url = cve_simple[key]['URL']
                break
        vulnerabilities.append(Vulnerability(cve[1], 0.0, 'n/a', cve[0], 0.0, description, url))
    return vulnerabilities


def CVE_interpreter(vulnerabilities):

    affected_programs = {}
    for vuln in vulnerabilities:
        if vuln.app_name in affected_programs.keys():
            affected_programs[vuln.app_name].add_vulnerability(vuln)
        else:
            affected_programs[vuln.app_name] = VulnerableApplication(vuln.app_name)
            affected_programs[vuln.app_name].add_vulnerability(vuln)

    return affected_programs

if __name__ == "__main__":
    CVE_folder_setup()
    fetch_CVEs()

    apps = get_installed_apps()
    save_to_csv(apps)
    print(apps)
    cpes = cpe_fetcher_mainprocess(apps)

    for cpe in cpes:
        print(cpe)

    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []

    print('---------------------')
    #print(cves)
    for cve in cves:
        pprint(cve[0])
        cve_ids.append([cve[0].id, cve[1]])

    for cve_id in cve_ids:
        print(cve_id)

    vulnerabilities_fetcher(cve_ids)



    vulnerabilities = vulnerabilities_fetcher(cve_ids)

    for vuln in vulnerabilities:
        print(vuln)

    vulnerabilities = CVE_metric(vulnerabilities)

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        print(interpreted[i])


    exit(1)

    for app in apps:

        r = nvdlib.searchCPE(keywordSearch=app['name'], limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        print(app['name'])
        print(r)