import csv
import wmi
import winreg

import nvdlib

import multiprocessing as mp
import subprocess
from pprint import pprint

import requests
from packaging import version

from vulnerability_classes import *
from vulnerabilities_metrics import *
from mitrecve import crawler

import pandas as pd
import re


def get_installed_apps2():
    w = wmi.WMI()
    apps = []

    # Get apps from Win32_Product WMI class
    for product in w.query("SELECT * FROM Win32_Product"):
        app = {
            "name": product.Name,
            "version": product.Version,
            "vendor": product.Vendor,
            "install_date": str(product.InstallDate),
        }
        apps.append(app)

    # Get apps from UninstallKey registry keys
    registry_keys = [
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    ]

    for registry_key in registry_keys:
        for i in range(1000):
            try:
                subkey = winreg.EnumKey(registry_key, i)
                key = winreg.OpenKey(registry_key, subkey)
                name = winreg.QueryValueEx(key, "DisplayName")[0]
                version = winreg.QueryValueEx(key, "DisplayVersion")[0]
                publisher = winreg.QueryValueEx(key, "Publisher")[0]
                install_date = winreg.QueryValueEx(key, "InstallDate")[0]

                app = {
                    "name": name,
                    "version": version,
                    "vendor": publisher,
                    "install_date": install_date,
                }
                apps.append(app)
            except EnvironmentError:
                break

    return apps

def get_installed_apps():
    # to get the path of the powershell
    powershell_path = r'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'

    # the command to get the list of application and their versions
    powershell_command = r'Get-Package -ProviderName Programs,msi | Select-Object Name, Version | Export-Csv -Path apps.csv -NoTypeInformation'
    # to actually execute the command
    subprocess.call([powershell_path, "-Command", powershell_command], shell=True)

    # use of pandas to remove all empty lines
    apps = pd.read_csv('apps.csv')
    apps = apps.dropna()

    apps['Version'] = apps['Version'].apply(lambda x: re.findall(r'\b\d+(?:\.\d+)*\b', x))

    list_of_apps = apps.to_dict(orient='records')
    dict_of_apps = [{'name': d['Name'], 'version': d['Version'][0]} for d in list_of_apps]

    print(dict_of_apps)

    return dict_of_apps

    # to delete the csv file :
    # subprocess.call([powershell_path, "-Command", "rm apps.csv", shell=True)

def save_to_csv(apps, file_name="windows_apps.csv"):
    keys = apps[0].keys()

    with open(file_name, "w", newline="", encoding="utf-8") as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(apps)

    print(f"CSV file saved as {file_name}")


def cpe_fetcher_subprocess(app, pipe):
    CPE = None
    if(app['name'] == None):
        pipe.send(CPE)
        return
    words = app['name'].split(" ")
    if len(words) > 3:
        simpler_name = words[0] + ' ' + words[1] + ' ' + words[2]
    else:
        simpler_name = app['name']
    print(simpler_name)
    try:

        r = nvdlib.searchCPE(keywordSearch=simpler_name, limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        for i in r:

            cpe = i.cpeName

            if('android' in cpe):
                print('android')
                continue
            try:
                cpe_parts = cpe.split(":")
                cpe = cpe_parts[0] + ":" + cpe_parts[1] + ":" + cpe_parts[2] + ":" + cpe_parts[3] + ":" + cpe_parts[4] + ":" + app['version']
                pipe.send([cpe, app])
                return
            except Exception as e:
                print(e)

    except Exception as e:
        print(e)
        CPE = None
    pipe.send(CPE)
    return

def cpe_fetcher_mainprocess(apps):
    processes = []
    cpes = []
    for app in apps:
        #value = mp.Value('array')
        #values.append(value)

        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cpe_fetcher_subprocess, args=(app, child_conn)), parent_conn])
    for process in processes:
        process[0].start()

    for process in processes:
        #print(process[1].recv())
        cpes.append(process[1].recv())

        process[0].join()


    #After processes
    parsed_cpes = []
    for cpe in cpes:
        if cpe != None:
            if cpe not in parsed_cpes:
                parsed_cpes.append(cpe)


    return parsed_cpes


def cve_fetcher_subprocess(cpe, pipe):
    cves = []

    try:
        r = nvdlib.searchCVE(cpeName=cpe[0], key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
    except Exception as e:
        print(e)
        pipe.send([])
        return
    for i in r:
        cves.append([i, cpe[1]])
    pipe.send(cves)
    return



def cve_fetcher_mainprocess(cpes):
    processes = []
    cves = []
    merged_cves = []
    for cpe in cpes:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=cve_fetcher_subprocess, args=(cpe, child_conn)), parent_conn])
    for process in processes:
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        cves.append(process[1].recv())
        process[0].join()
    #print(cves)


    for i in cves:
        for j in i:
            merged_cves.append(j)
    return merged_cves



def vulnerabilities_fetcher(cves):
    vulnerabilities = []
    index = 0
    total = len(cves)
    for cve in cves:
        index += 1
        print(f'{index} / {total}')
        description = ''
        url = ''
        cve_simple = crawler.get_main_page(cve[0])
        for key in cve_simple.keys():
            if(cve[0] == cve_simple[key]['ID']):
                description = cve_simple[key]['DESC']
                url = cve_simple[key]['URL']
                break
        vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, description, url))
    return vulnerabilities

"""def vulnerabilities_fetcher2(cves): 
    group_cves = regroup_by_name(cves)
    for key in group_cves.keys():
        cve_simple = crawler.get_main_page(key)
        for key2 in cve_simple.keys():
            description = ''
            url = ''
            if(cve[0] == cve_simple[key2]['ID']):
                description = cve_simple[key2]['DESC']
                url = cve_simple[key2]['URL']

                vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, description, url))"""

def vulnerabilities_fetcher3(cves):
    vulnerabilities = []
    for cve in cves:
        vulnerabilities.append(Vulnerability(cve[1]['name'], cve[1]['version'], '', cve[0], 0.0, '', ''))
    return vulnerabilities

def regroup_by_name(cves):
    dic = {}
    for cve in cves:
        if cve[1]['name'] not in dic.keys():
            dic[cve[1]['name']] = [cve]
        else:
            dic[cve[1]['name']].append(cve)
    return dic

def degroup(dic):
    array = []
    for key in dic.keys():
        for cve in dic[key]:
            array.append(cve)
    return array

def CVE_interpreter(vulnerabilities):

    affected_programs = {}
    total = len(vulnerabilities)
    for vuln in vulnerabilities:
        if vuln.app_name in affected_programs.keys():
            affected_programs[vuln.app_name].add_vulnerability(vuln)
        else:
            affected_programs[vuln.app_name] = VulnerableApplication(vuln.app_name)
            affected_programs[vuln.app_name].add_vulnerability(vuln)

    return affected_programs

if __name__ == "__main__":
    apps = get_installed_apps()
    print(apps)
    #save_to_csv(apps)
    #print(apps)
    #cve_simple = crawler.get_main_page('CVE-2017-11843')
    #print(cve_simple)
    cpes = cpe_fetcher_mainprocess(apps)

    for cpe in cpes:
        print(cpe)

    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []

    print('---------------------')
    #print(cves)
    for cve in cves:
        #pprint(cve[0])
        cve_ids.append([cve[0].id, cve[1]])

    for cve_id in cve_ids:
        print(cve_id)

    #vulnerabilities_fetcher(cve_ids)



    vulnerabilities = vulnerabilities_fetcher3(cve_ids)

    for vuln in vulnerabilities:
        print(vuln)

    vulnerabilities = CVE_metric(vulnerabilities)

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        print(interpreted[i])


    exit(1)

    for app in apps:

        r = nvdlib.searchCPE(keywordSearch=app['name'], limit=10, key='bfe1caa9-727e-45db-aa28-fc494c051b9b', delay=1)
        print(app['name'])
        print(r)

def main():
    apps = get_installed_apps()

    cpes = cpe_fetcher_mainprocess(apps)



    cves = cve_fetcher_mainprocess(cpes)
    cve_ids = []


    for cve in cves:

        cve_ids.append([cve[0].id, cve[1]])

    vulnerabilities = vulnerabilities_fetcher3(cve_ids)

    vulnerabilities = CVE_metric(vulnerabilities)

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        #print(interpreted[i])
    return interpreted