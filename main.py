# This is a sample Python script.
import os
import subprocess
import tkinter as tk
from tkinter import ttk
import requests
import pandas as pd

import seaborn as sns
from mitrecve import crawler
from pprint import pprint
from packaging import version
import re
from bs4 import BeautifulSoup


from pathlib import Path
import json
import multiprocessing as mp

import csv
import wmi
import winreg


# Press Maj+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
'''
"DisplayName,""Publisher"",""InstallDate"",""DisplayVersion"""
"Visual Studio Build Tools 2019,""Microsoft Corporation"",""20240130"",""16.11.33"""
"Brave,""Brave Software Inc"",""20240307"",""122.1.63.169"""
,,,
"Foxit PDF Reader,""Foxit Software Inc."",""20240129"",""2023.3.0.23028"""
"IntelliJ IDEA 2023.3.3,""JetBrains s.r.o."",,""233.14015.106"""
"Microsoft Edge,""Microsoft Corporation"",""20240309"",""122.0.2365.80"""
"Microsoft Edge Update,,,""1.3.185.21"""
"Microsoft Edge WebView2 Runtime,""Microsoft Corporation"",""20240310"",""122.0.2365.80"""
"STMicroelectronics STM32CubeIDE 1.14.1,""STMicroelectronics"",,""1.14.1"""
"WebStorm 2023.3.3,""JetBrains s.r.o."",,""233.14015.89"""
,,,
"Universal CRT Redistributable,""Microsoft Corporation"",""20240130"",""10.0.26624"""
"vs_FileTracker_Singleton,""Microsoft Corporation"",""20240130"",""16.10.31303"""
"HP Hotkey Support,""HP Inc."",""20240130"",""6.2.53.1"""
"Safe Exam Browser,""ETH Z?rich"",,""3.6.0.633"""
"Intel(R) Trusted Connect Services Client,""Intel Corporation"",,""1.65.245.0"""
"Microsoft Visual C++ 2015-2022 Redistributable (x64) - 14.38.33130,""Microsoft Corporation"",,""14.38.33130.0"""
"Microsoft Visual C++ 2015-2022 Redistributable (x86) - 14.38.33130,""Microsoft Corporation"",,""14.38.33130.0"""
"Python Launcher,""Python Software Foundation"",""20240130"",""3.12.1150.0"""
,,,
"Microsoft Visual C++ 2022 X86 Additional Runtime - 14.38.33130,""Microsoft Corporation"",""20240130"",""14.38.33130"""
"Microsoft Visual Studio Setup Configuration,""Microsoft Corporation"",""20240130"",""3.7.2182.35401"""
"Microsoft VC++ redistributables repacked.,""Intel Corporation"",""20240130"",""12.0.0.0"""
"vcpp_crt.redist.clickonce,""Microsoft Corporation"",""20240130"",""14.29.30153"""
"Intel(R) Trusted Connect Service Client x86,""Intel Corporation"",""20240130"",""1.65.245.0"""
"Microsoft Visual C++ 2019 X86 Debug Runtime - 14.29.30153,""Microsoft Corporation"",""20240130"",""14.29.30153"""
"Microsoft Visual C++ 2022 X86 Minimum Runtime - 14.38.33130,""Microsoft Corporation"",""20240130"",""14.38.33130"""
"Microsoft Visual Studio Setup WMI Provider,""Microsoft Corporation"",""20240130"",""3.7.2182.35401"""
"Intel(R) Chipset Device Software,""Intel(R) Corporation"",,""10.1.18243.8188"""
"STMicroelectronics stlink-server,""STMicroelectronics"",""20240305"",""2.1.1-1"""
'''


class VulnerableApplication:
    def __init__(self, app_name):
        self.app_name = app_name
        self.danger = None
        self.max_score = 0.0
        self.cve_number = 0
        #self.color_scale = 0
        self.related_vulnerabilities = []

    def add_vulnerability(self, vulnerability):
        if vulnerability.app_name == self.app_name:
            self.cve_number += 1
            self.related_vulnerabilities.append(vulnerability)
            known = False
            if vulnerability.V2metrics != None:
                V2_score = float(vulnerability.V2metrics.base_score)
                #V2_severity = vulnerability.V2metrics.base_severity
                self.max_score = max(self.max_score, V2_score)
                known = True
            if vulnerability.V30metrics != None:
                V30_score = float(vulnerability.V30metrics.base_score)
                #V2_severity = vulnerability.V2metrics.base_severity
                self.max_score = max(self.max_score, V30_score)
                known = True
            if vulnerability.V31metrics != None:
                V31_score = float(vulnerability.V31metrics.base_score)
                #V2_severity = vulnerability.V2metrics.base_severity
                self.max_score = max(self.max_score, V31_score)
                known = True


    def determine_danger(self):
        if self.max_score >= 9.0:
            self.danger = 'CRITICAL'
        elif self.max_score >= 7.0:
            self.danger = 'HIGH'
        elif self.max_score >= 4.0:
            self.danger = 'MEDIUM'
        elif self.max_score >= 0.1:
            self.danger = 'LOW'
        else:
            self.danger = 'NONE'


    def __str__(self):
        output = 'Color Scale : ' + str(self.max_score) + ' App Name : ' + str(self.app_name) + ' Danger : ' + str(self.danger) + ' Number of vulnerabilities : ' + str(self.cve_number)
        return output



class CVSS_V2:
    """
    Class for CVSS (Common Vulnerability Scoring System) Version 2
    """
    def __init__(self, base_severity, access_complexity, access_vector, authentication, availability_impact, base_score, confidentiality_impact, integrity_impact, vector_string, exploitability_score, impact_score) :
        self.base_severity = base_severity
        self.access_complexity = access_complexity
        self.access_vector = access_vector
        self.authentication = authentication
        self.availability_impact = availability_impact
        self.base_score = base_score
        self.confidentiality_impact = confidentiality_impact
        self.integrity_impact = integrity_impact
        self.vector_string = vector_string
        self.exploitability_score = exploitability_score
        self.impact_score = impact_score


    def __str__(self):
        return ('Base Score : ' + str(self.base_score) + '\nBase Severity : ' + str(
            self.base_severity) + '\nExploitability Score : ' + str(
            self.exploitability_score) + '\nImpact Score : ' + str(self.impact_score))


""" Data in the local json file
'cvssMetricV30': [{'cvssData': {'attackComplexity': 'LOW',
                                                     'attackVector': 'NETWORK',
                                                     'availabilityImpact': 'NONE',
                                                     'baseScore': 8.2,
                                                     'baseSeverity': 'HIGH',
                                                     'confidentialityImpact': 'LOW',
                                                     'integrityImpact': 'HIGH',
                                                     'privilegesRequired': 'NONE',
                                                     'scope': 'CHANGED',
                                                     'userInteraction': 'REQUIRED',
                                                     'vectorString': 'CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:N',
                                                     'version': '3.0'},
                                        'exploitabilityScore': 2.8,
                                        'impactScore': 4.7,"""

class CVSS_V30:
    """
    Class for CVSS (Common Vulnerability Scoring System) Version 3.0
    """
    def __init__(self, attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previleges_required, scope, user_interaction, vector_string, exploitability_score, impact_score):
        self.attack_complexity = attack_complexity
        self.attack_vector = attack_vector
        self.availability_impact = availability_impact
        self.base_score = base_score
        self.base_severity = base_severity
        self.confidentiality_impact = confidentiality_impact
        self.integrity_impact = integrity_impact
        self.previleges_required = previleges_required
        self.scope = scope
        self.user_interaction = user_interaction
        self.vector_string = vector_string
        self.exploitability_score = exploitability_score
        self.impact_score = impact_score

class CVSS_V31:
    """
    Class for CVSS (Common Vulnerability Scoring System) Version 3.1
    """
    def __init__(self, attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previleges_required, scope, user_interaction, vector_string, exploitability_score, impact_score):
        self.attack_complexity = attack_complexity
        self.attack_vector = attack_vector
        self.availability_impact = availability_impact
        self.base_score = base_score
        self.base_severity = base_severity
        self.confidentiality_impact = confidentiality_impact
        self.integrity_impact = integrity_impact
        self.previleges_required = previleges_required
        self.scope = scope
        self.user_interaction = user_interaction
        self.vector_string = vector_string
        self.exploitability_score = exploitability_score
        self.impact_score = impact_score


class Vulnerability:
    """
    Class representing one vulnerabilty for one application (one CVE)
    """
    def __init__(self, app_name, current_version, publisher, cve_id, affected_version,
                 description, url):
        self.app_name = str(app_name)
        self.current_version = str(current_version)
        self.publisher = str(publisher)
        self.cve_id = str(cve_id)
        #self.severity = str(severity)
        #self.base_score = str(base_score)
        self.affected_version = str(affected_version)
        self.description = str(description)
        self.url = str(url)
        self.V2metrics = None
        self.V30metrics = None
        self.V31metrics = None

    def __str__(self):


        output = str('App Name : ' + self.app_name +
                '\nCurrent Version : ' + self.current_version +
                '\nPublisher : ' + self.publisher +
                '\nCVE ID : ' + self.cve_id +
                #'\nSeverity : ' + self.severity +
                #'\nBase Score : ' + self.base_score +
                '\nAffected Version : ' + self.affected_version +
                '\nDescription : ' + self.description +
                '\nURL : ' + self.url)
        if self.V2metrics != None:
            output = output + str('\nV2metrics : ' +
                    '\n-Base Score : ' + str(self.V2metrics.base_score) +
                    '\n-Base Severity : ' + str(self.V2metrics.base_severity) +
                    '\n-Exploitability Score : ' + str(self.V2metrics.exploitability_score) +
                    '\n-Impact Score : ' + str(self.V2metrics.impact_score))
        if self.V30metrics != None:
            output = output + str('\nV30metrics : ' +
                                  '\n-Base Score : ' + str(self.V30metrics.base_score) +
                                  '\n-Base Severity : ' + str(self.V30metrics.base_severity) +
                                  '\n-Exploitability Score : ' + str(self.V30metrics.exploitability_score) +
                                  '\n-Impact Score : ' + str(self.V30metrics.impact_score))
        if self.V31metrics != None:
            output = output + str('\nV31metrics : ' +
                                  '\n-Base Score : ' + str(self.V31metrics.base_score) +
                                  '\n-Base Severity : ' + str(self.V31metrics.base_severity) +
                                  '\n-Exploitability Score : ' + str(self.V31metrics.exploitability_score) +
                                  '\n-Impact Score : ' + str(self.V31metrics.impact_score))
        return output



def get_installed_apps():
    w = wmi.WMI()
    apps = []

    # Get apps from Win32_Product WMI class
    for product in w.query("SELECT * FROM Win32_Product"):
        app = {
            "name": product.Name,
            "version": product.Version,
            "vendor": product.Vendor,
            "install_date": str(product.InstallDate),
        }
        apps.append(app)

    # Get apps from UninstallKey registry keys
    registry_keys = [
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    ]

    for registry_key in registry_keys:
        for i in range(1000):
            try:
                subkey = winreg.EnumKey(registry_key, i)
                key = winreg.OpenKey(registry_key, subkey)
                name = winreg.QueryValueEx(key, "DisplayName")[0]
                version = winreg.QueryValueEx(key, "DisplayVersion")[0]
                publisher = winreg.QueryValueEx(key, "Publisher")[0]
                install_date = winreg.QueryValueEx(key, "InstallDate")[0]

                app = {
                    "name": name,
                    "version": version,
                    "vendor": publisher,
                    "install_date": install_date,
                }
                apps.append(app)
            except EnvironmentError:
                break

    return apps

def save_to_csv(apps, file_name="windows_apps.csv"):
    keys = apps[0].keys()

    with open(file_name, "w", newline="", encoding="utf-8") as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(apps)

    print(f"CSV file saved as {file_name}")


def create_vulnerability(program, cve, json_file, detected_version='Unknown'):
    """
    Create a vulnerability object
    :param program: array with [0]: program name & [1]: program version
    :param cve: CVE detected by the mitre API
    :param json_file: Json file from cveawg.mitre.org's API
    :param detected_version: affected version of the application
    :return: vulnerability object
    """
    app_name = program[0]
    current_version = program[1]
    try:
        publisher = json_file['containers']['cna']['affected'][0]['vendor']
    except KeyError:
        publisher = 'Unknown'
    cve_id = cve['ID']

    """try:
        severity = json_file['containers']['cna']['metrics'][0]['cvssV3_1']['baseSeverity']
    except KeyError:
        severity = 'Unknown'
    try:
        base_score = json_file['containers']['cna']['metrics'][0]['cvssV3_1']['baseScore']
    except KeyError:
        base_score = 'Unknown'
        """
    try:
        affected_version = json_file['containers']['cna']['affected'][0]['versions'][0]['lessThan']
    except KeyError:
        try:
            affected_version = json_file['containers']['cna']['affected'][0]['versions'][0]['lessThanOrEqual']
        except KeyError:
            try:
                affected_version = (json_file['containers']['cna']['affected'][0]['versions'][0]['version'])
            except KeyError:
                affected_version = detected_version

    description = cve['DESC']
    url = cve['URL']

    return Vulnerability(app_name, current_version, publisher, cve_id, affected_version,description, url)


def fetch_subprocess(program, pipe):
    """
    Subprocess for CVE generator.
    program ->
    :param program: list with [0]: program name & [1]: program version
    :param pipe: transfer ID
    :return: array of vulnerability objects linked to the program // USELESS // replaced by pipe.send() method
    """
    vulnerabilities = []
    index = 0

    cve_simple = crawler.get_main_page(str(program[0]))
    # cve_array = [x['ID'] for x in cve_simple.values()]

    # for j in cve_array:
    for j in cve_simple.values():
        index += 1
        url = 'https://cveawg.mitre.org/api/cve/' + j['ID']
        request = requests.get(url)
        if request.status_code == 200:
            print('OK - ' + str(index) + ' - ' + str(program[0]))
            # pprint(request.json())
            try:
                keys = request.json()['containers']['cna']['affected'][0]['versions'][0].keys()
            except KeyError:
                keys = ''
                print("Key Error")
            if ('lessThan' in keys):
                try:
                    if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0][
                                         'lessThan']) > version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json()))
                        print('Added')
                        continue
                    else:
                        print('Not Added')
                        continue
                except Exception as e:
                    print("Exception ! - Less")
                    print(e)
                    # WARNING exception doesn't add new vulnerability (no more checks) Corrected ?

            if ('lessThanOrEqual' in keys):
                try:
                    if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0][
                                         'lessThanOrEqual']) >= version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json()))
                        print('Added - equal')
                        continue
                    else:
                        print('Not Added - equal')
                        continue
                except Exception as e:
                    print("Exception ! - Equal")
                    print(e)
            # else:
            try:
                version_temp = version_parser(
                    request.json()['containers']['cna']['affected'][0]['versions'][0]['version'])
            except Exception as e:
                print("Key Error - else")
                print(e)
                vulnerabilities.append(create_vulnerability(program, j, request.json()))
                continue
            if (version_temp == None):

                vulnerabilities.append(create_vulnerability(program, j, request.json()))
                print('Added - Unknown')

            else:
                try:
                    if version.parse(version_temp) >= version.parse(program[1]):
                        vulnerabilities.append(create_vulnerability(program, j, request.json(), version_temp))
                        print('Added - parse')
                    else:
                        print('Not Added - parse')
                except Exception as e:
                    vulnerabilities.append(create_vulnerability(program, j, request.json(), version_temp))
                    print("Exception ! - Parse")
                    print(e)
    pipe.send(vulnerabilities)
    return vulnerabilities


def cve_fetcher_mainprocess(programs): #V2
    """
    Main process for CVE generator.
    Uses fetch_subprocess() method for each program (Parallel processing)
    :param programs: array of arrays with [0]: program name & [1]: program version
    :return: array with all the configuration's CVEs
    """
    processes = []
    vulnerabilities = []
    merged_list = []
    for program in programs:
        #value = mp.Value('array')
        #values.append(value)
        parent_conn, child_conn = mp.Pipe()
        processes.append([mp.Process(target=fetch_subprocess, args=(program, child_conn)), parent_conn])
    for process in processes:
        process[0].start()
    for process in processes:
        #print(process[1].recv())
        vulnerabilities.append(process[1].recv())
        process[0].join()
    for i in vulnerabilities:
        for j in i:
            merged_list.append(j)
    return merged_list


def cpe_to_cve(programs): #V1
    """
    OLD process for CVE generation / DEPRECIATED
    :param programs: array of arrays with [0]: program name & [1]: program version
    :return: array with all the system's CVEs
    """
    vulnerabilities = []
    index = 0
    for i in programs:
        print(i)
        cve_simple = crawler.get_main_page(i[0])
        # cve_array = [x['ID'] for x in cve_simple.values()]

        # for j in cve_array:
        for j in cve_simple.values():
            index += 1
            url = 'https://cveawg.mitre.org/api/cve/' + j['ID']
            request = requests.get(url)
            if request.status_code == 200:
                print('OK - ' + str(index))
                #pprint(request.json())
                try:
                    keys = request.json()['containers']['cna']['affected'][0]['versions'][0].keys()
                except KeyError:
                    keys = ''
                    print("Key Error")
                if ('lessThan' in keys):
                    try:
                        if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0]['lessThan']) > version.parse(i[1]):
                            vulnerabilities.append(create_vulnerability(i, j, request.json()))
                            print('Added')
                            continue
                        else:
                            print('Not Added')
                            continue
                    except Exception as e:
                        print("Exception ! - Less")
                        print(e)
                        #WARNING exception doesn't add new vulnerability (no more checks) Corrected ?

                if ('lessThanOrEqual' in keys):
                    try:
                        if version.parse(request.json()['containers']['cna']['affected'][0]['versions'][0][
                                             'lessThanOrEqual']) >= version.parse(i[1]):
                            vulnerabilities.append(create_vulnerability(i, j, request.json()))
                            print('Added - equal')
                            continue
                        else:
                            print('Not Added - equal')
                            continue
                    except Exception as e:
                        print("Exception ! - Equal")
                        print(e)
                #else:
                try:
                    version_temp = version_parser(request.json()['containers']['cna']['affected'][0]['versions'][0]['version'])
                except Exception as e:
                    print("Key Error - else")
                    print(e)
                    vulnerabilities.append(create_vulnerability(i, j, request.json()))
                    continue
                if (version_temp == None):

                    vulnerabilities.append(create_vulnerability(i, j, request.json()))
                    print('Added - Unknown')

                else:
                    try:
                        if version.parse(version_temp) >= version.parse(i[1]):
                            vulnerabilities.append(create_vulnerability(i, j, request.json(), version_temp))
                            print('Added - parse')
                        else:
                            print('Not Added - parse')
                    except Exception as e:
                        vulnerabilities.append(create_vulnerability(i, j, request.json(), version_temp))
                        print("Exception ! - Parse")
                        print(e)



    return vulnerabilities


def get_programs():
    # to get the path of the powershell
    powershell_path = r'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'

    # the command to get the list of application and their versions
    powershell_command = r'Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion | Export-Csv -Path apps.csv -NoTypeInformation'

    # to actually execute the command
    subprocess.call([powershell_path, "-Command", powershell_command], shell=True)

    # use of pandas to remove all empty lines
    apps = pd.read_csv('apps.csv')
    apps = apps.dropna(how='all')
    print(apps.head(8))

    # to convert the pandas dataframe to an array
    applications_array = apps.values.tolist()

    # to delete the csv file :
    # subprocess.call([powershell_path, "-Command", "rm apps.csv"], shell=True)
    return applications_array




def version_parser(v):
    try:
        versionPattern = r'\d+(=?\.(\d+(=?\.(\d+)*)*)*)*'
        regexMatcher = re.compile(versionPattern)
        return regexMatcher.search(v).group(0)
    except:
        return None

def dbjson_to_dic(json):
    dic = {}
    for vuln in json['vulnerabilities']:
        #print('OK')
        key = vuln['cve']['id']
        dic[key] = vuln
    return dic

def CVSS_V2_parser(metric):
    """
    Get CVSS V2 score from json data
    :param metric: V2 metric in json format
    :return: CVSS_V2 object or None if unable to parse
    """
    try:
        #(self, base_severity, access_complexity, access_vector, authentication, availability_impact, base_score, confidentiality_impact, integrity_impact, vector_string, exploitability_score, impact_score)
        base_severity = metric[0]['baseSeverity']
        access_complexity = metric[0]['cvssData']['accessComplexity']
        access_vector = metric[0]['cvssData']['accessVector']
        authentication = metric[0]['cvssData']['authentication']
        availability_impact = metric[0]['cvssData']['availabilityImpact']
        base_score = metric[0]['cvssData']['baseScore']
        confidentiality_impact = metric[0]['cvssData']['confidentialityImpact']
        integrity_impact = metric[0]['cvssData']['integrityImpact']
        vector_string = metric[0]['cvssData']['vectorString']
        exploitability_score = metric[0]['exploitabilityScore']
        impact_score = metric[0]['impactScore']

        new_metric = CVSS_V2(base_severity, access_complexity, access_vector, authentication, availability_impact, base_score, confidentiality_impact, integrity_impact, vector_string, exploitability_score, impact_score)
        return new_metric
    except Exception as e:
        print('Unable to parse V2 metric')
        print(e)
        return None


def CVSS_V30_parser(metric):
    """
    Get CVSS V3.0 score from json data
    :param metric: V3.0 metric in json format
    :return: CVSS_V30 object or None if unable to parse
    """
    try:
        # (self, attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previliges_required, scope, user_interaction, vector_string, exploitability_score, impact_score)
        attack_complexity = metric[0]['cvssData']['attackComplexity']
        attack_vector = metric[0]['cvssData']['attackVector']
        availability_impact = metric[0]['cvssData']['availabilityImpact']
        base_score = metric[0]['cvssData']['baseScore']
        base_severity = metric[0]['cvssData']['baseSeverity']
        confidentiality_impact = metric[0]['cvssData']['confidentialityImpact']
        integrity_impact = metric[0]['cvssData']['integrityImpact']
        previliges_required = metric[0]['cvssData']['privilegesRequired']
        scope = metric[0]['cvssData']['scope']
        user_interaction = metric[0]['cvssData']['userInteraction']
        vector_string = metric[0]['cvssData']['vectorString']
        exploitability_score = metric[0]['exploitabilityScore']
        impact_score = metric[0]['impactScore']


        new_metric = CVSS_V30(attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previliges_required, scope, user_interaction, vector_string, exploitability_score, impact_score)
        return new_metric
    except Exception as e:
        print('Unable to parse V30 metric')
        print(e)
        return None

def CVSS_V31_parser(metric):
    """
    Get CVSS V3.1 score from json data
    :param metric: V3.1 metric in json format
    :return: CVSS_V31 object or None if unable to parse
    """
    try:
        # (self, attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previliges_required, scope, user_interaction, vector_string, exploitability_score, impact_score)
        attack_complexity = metric[0]['cvssData']['attackComplexity']
        attack_vector = metric[0]['cvssData']['attackVector']
        availability_impact = metric[0]['cvssData']['availabilityImpact']
        base_score = metric[0]['cvssData']['baseScore']
        base_severity = metric[0]['cvssData']['baseSeverity']
        confidentiality_impact = metric[0]['cvssData']['confidentialityImpact']
        integrity_impact = metric[0]['cvssData']['integrityImpact']
        previliges_required = metric[0]['cvssData']['privilegesRequired']
        scope = metric[0]['cvssData']['scope']
        user_interaction = metric[0]['cvssData']['userInteraction']
        vector_string = metric[0]['cvssData']['vectorString']
        exploitability_score = metric[0]['exploitabilityScore']
        impact_score = metric[0]['impactScore']


        new_metric = CVSS_V31(attack_complexity, attack_vector, availability_impact, base_score, base_severity, confidentiality_impact, integrity_impact, previliges_required, scope, user_interaction, vector_string, exploitability_score, impact_score)
        return new_metric
    except Exception as e:
        print('Unable to parse V31 metric')
        print(e)
        return None


def CVE_metric(vulnerabilities):
    """
    Process the CVSS scores (V2, V3.0 & V3.1) for every vulnerability in the system
    :param vulnerabilities:
    :return:
    """
    try:
        with open("./data.json", "r") as infile:
            data = json.load(infile)
            print(len(data['vulnerabilities']))
            for vuln in vulnerabilities:
                for cve in data['vulnerabilities']:
                    if cve['cve']['id'] == vuln.cve_id:
                        keys = cve['cve']['metrics'].keys()
                        temp = False
                        if 'cvssMetricV2' in keys:
                            vuln.V2metrics = CVSS_V2_parser(cve['cve']['metrics']['cvssMetricV2'])
                            temp = True
                        if 'cvssMetricV30' in keys:
                            vuln.V30metrics = CVSS_V30_parser(cve['cve']['metrics']['cvssMetricV30'])
                            temp = True
                        if 'cvssMetricV31' in keys:
                            vuln.V31metrics = CVSS_V31_parser(cve['cve']['metrics']['cvssMetricV31'])
                            temp = True

                        if not temp:

                            print(keys)
                            pprint(cve)
                        continue
    except Exception as e:
        print('Unable to open data.json')
        print(e)
    return vulnerabilities

def CVE_folder_setup():
    """
    Set up the "CVE" folder
    :return: None
    """
    data_path = Path('./')
    directories = [f for f in data_path.iterdir() if f.is_dir()]
    print(directories)
    print(Path('CVEs') in directories)
    if Path('CVEs') not in directories:
        os.mkdir('./CVEs', )

def fetch_CVEs():
    """
    Download every CVE from mitre database.
    Write data.json file.
    Can be used to update data.json file
    :return: 1
    """
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    request = requests.get("https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=1")
    total = request.json()['totalResults']
    print(total)

    data = {}
    data['vulnerabilities'] = []
    try:
        with open("./data.json", "r") as infile:
            data=json.load(infile)
            print(len(data['vulnerabilities']))
            if(len(data['vulnerabilities']) == total):
                print('JSON already up to date')
                #pprint(data['vulnerabilities'][:100])
                return 1
    except FileNotFoundError:
        data = {}
        data['vulnerabilities'] = []
    while(len(data['vulnerabilities']) < total):
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        url = url+'?startIndex='+str(len(data['vulnerabilities']))
        print(url)

        # A GET request to the API
        response = requests.get(url)

        print(response)
        #print(response.text)
        response_json = response.json()
        print(response_json['startIndex'])
        for vuln in response_json['vulnerabilities']:
            data['vulnerabilities'].append(vuln)
    json_data = json.dumps(data)
    with open("./data.json", "w") as outfile:
        outfile.write(json_data)
    return 1


def CVE_interpreter(vulnerabilities):

    affected_programs = {}
    for vuln in vulnerabilities:
        if vuln.app_name in affected_programs.keys():
            affected_programs[vuln.app_name].add_vulnerability(vuln)
        else:
            affected_programs[vuln.app_name] = VulnerableApplication(vuln.app_name)
            affected_programs[vuln.app_name].add_vulnerability(vuln)

    return affected_programs



# Press the green button in the gutter to run the script.
if __name__ == '__main__':

    apps = get_installed_apps()
    save_to_csv(apps)

    print('-------------------------------------------------------------')

    """cve_simple = crawler.get_main_page("cpe:2.3:a:adobe:acrobat_reader_dc:2021.001.20099")
    print(cve_simple)
    pprint(cve_simple.text)
    pprint(cve_simple.json())"""

    print('-----------------------------------------------')
    CVE_folder_setup()
    fetch_CVEs()
    programs = get_programs()
    programs2 = []
    print(programs)
    for i in programs:
        if 'NAN' not in str(i[0]).upper() and 'NAN' not in str(i[1]).upper():
            programs2.append(i)

    print(programs2)
    print(programs)
    programs4 = [['Visual Studio Build Tools 2019', '16.11.33'], ['Brave', '123.1.64.109'],
                 ['Foxit PDF Reader', '2024.1.0.23997'], ['IntelliJ IDEA 2023.3.3', '233.14015.106'],
                 ['Microsoft Edge', '122.0.2365.92']]
    programs41 =[['Visual Studio Build Tools 2019', '16.11.33'], ['Brave', '123.1.64.109'],
                 ['Foxit PDF Reader', '2024.1.0.23997'], ['IntelliJ IDEA 2023.3.3', '233.14015.106']]

    programs5 = [['Microsoft Office', '1.349.20.0']]
    programs6 = [['Microsoft Visual C++ 2022 X64 Debug Runtime - 14.36.32532', '14.36.32532']]
    vulnerabilities = cve_fetcher_mainprocess(programs41)
    """for i in vulnerabilities:
        print(i)
        print('\n')"""
    """print('Number of vulnerabilities : ')
    print(len(vulnerabilities))
    unknown_severity = [x for x in vulnerabilities if x.severity == 'Unknown']
    print('Number of unknown severity : ')
    print(len(unknown_severity))

    unknown_version = [x for x in vulnerabilities if x.affected_version == 'Unknown' or x.affected_version == 'n/a']
    print('Number of unknown affected version : ')
    print(len(unknown_version))"""

    print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')

    vulnerabilities = CVE_metric(vulnerabilities)
    for i in vulnerabilities:
        print(i)
        print('\n')

    interpreted = CVE_interpreter(vulnerabilities)
    for i in interpreted.keys():
        interpreted[i].determine_danger()
        print(interpreted[i])


    print('================================================')

    if(True):
        exit(1)

    '''
    cve_simple = crawler.get_main_page('Microsft Office')
    cve_array = [x['ID'] for x in cve_simple.values()]
    print(cve_array)'''

    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0?startIndex=100000"

    # A GET request to the API
    response = requests.get(url)

    # Print the response
    response_json = response.json()
    #print(response_json['totalResults'])
    #pprint(response_json)

    print(response_json.keys())
    #pprint(response_json['vulnerabilities'][:100])

    print(response.status_code)

    cve_dic = dbjson_to_dic(response_json)
    print(cve_dic.keys())
    print(len(cve_dic))
    print(len(response_json['vulnerabilities']))
    print(response_json['startIndex'])


    # print(CVSS(vector).severities())

    vector_string = "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
    # score = cvss_vector_to_score(vector_string)
    # print("CVSS score:", score)

    # c = pycvss.from_vector('AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H')

    # print(c.base_score())
    # Example of vector
    # AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

    programs = get_programs()
    programs2 = []
    print(programs)
    for i in programs:
        if 'NAN' not in str(i[0]).upper() and 'NAN' not in str(i[1]).upper():
            programs2.append(i)

    print(programs2)

    programs3 = [['Visual Studio Build Tools 2019', '16.11.33'], ['Brave', '123.1.64.109'],
                 ['Foxit PDF Reader', '2024.1.0.23997'], ['IntelliJ IDEA 2023.3.3', '233.14015.106'],
                 ['Microsoft Edge', '122.0.2365.92'], ['Microsoft Edge Update', '1.3.185.21'],
                 ['Microsoft Edge WebView2 Runtime', '122.0.2365.92'],
                 ['STMicroelectronics STM32CubeIDE 1.14.1', '1.14.1'], ['WebStorm 2023.3.3', '233.14015.89'],
                 ['Universal CRT Redistributable', '10.0.26624'], ['vs_FileTracker_Singleton', '16.10.31303'],
                 ['HP Hotkey Support', '6.2.53.1'], ['Safe Exam Browser', '3.6.0.633'],
                 ['Intel(R) Trusted Connect Services Client', '1.65.245.0'],
                 ['Microsoft Visual C++ 2015-2022 Redistributable (x64) - 14.38.33130', '14.38.33130.0'],
                 ['Microsoft Visual C++ 2015-2022 Redistributable (x86) - 14.38.33130', '14.38.33130.0'],
                 ['Python Launcher', '3.12.1150.0'],
                 ['Microsoft Visual C++ 2022 X86 Additional Runtime - 14.38.33130', '14.38.33130'],
                 ['Microsoft Visual Studio Setup Configuration', '3.7.2182.35401'],
                 ['Microsoft VC++ redistributables repacked.', '12.0.0.0'],
                 ['vcpp_crt.redist.clickonce', '14.29.30153'],
                 ['Intel(R) Trusted Connect Service Client x86', '1.65.245.0'],
                 ['Microsoft Visual C++ 2019 X86 Debug Runtime - 14.29.30153', '14.29.30153'],
                 ['Microsoft Visual C++ 2022 X86 Minimum Runtime - 14.38.33130', '14.38.33130'],
                 ['Microsoft Visual Studio Setup WMI Provider', '3.7.2182.35401'],
                 ['Intel(R) Chipset Device Software', '10.1.18243.8188'],
                 ['STMicroelectronics stlink-server', '2.1.1-1']]

    programs4 = [['Visual Studio Build Tools 2019', '16.11.33'], ['Brave', '123.1.64.109'],
                 ['Foxit PDF Reader', '2024.1.0.23997'], ['IntelliJ IDEA 2023.3.3', '233.14015.106'],
                 ['Microsoft Edge', '122.0.2365.92']]

    programs5 = [['Microsoft Office', '1.349.20.0']]
    """vulnerabilities = cpe_to_cve(programs5)
    # print(vulnerabilities)
    print(len(vulnerabilities))
    for i in vulnerabilities:
        print(i)
        print('\n')
    print('Number of vulnerabilities : ')
    print(len(vulnerabilities))
    unknown_severity = [x for x in vulnerabilities if x.severity == 'Unknown']
    print('Number of unknown severity : ')
    print(len(unknown_severity))

    unknown_version = [x for x in vulnerabilities if x.affected_version == 'Unknown' or x.affected_version == 'n/a']
    print('Number of unknown affected version : ')
    print(len(unknown_version))"""